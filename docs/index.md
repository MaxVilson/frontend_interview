### Какие методы HTTP-запросов вы знаете?
<details>
  <summary>Ответ:</summary>
    <p>Аббревиатура HTTP расшифровывается как Hyper Text Transfer Protocol, или в переводе «протокол передачи гипертекста». Протокол HTTP служит для передачи данных между пользовательским приложением (как правило, браузером) и веб-сервером. </p>
    <p><b>GET</b> Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value)</p>
    <p><b>POST</b> Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.</p>
    <p><b>HEAD</b> Здесь придется забежать немного вперед и сказать, что обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.</p>
    <p><b>PUT</b> Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности/</p>
    <p><b>DELETE</b>	Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.</p>
    <p><b>OPTIONS</b> Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.</p>
    <p><b>PATCH</b> Позволяет внести частичные изменения в указанный ресурс по указанному расположению.</p>
</details>

### Какие версии HTTP-протокола вам известны?
<details>
  <summary>Ответ:</summary>
    <p>Версию<b> HTTP 0.9</b> (1991) рассматривать не будем, так как это было «давно и неправда». Можно было запрашивать данные через GET и все.</p>
    <p><b>HTTP 1.0</b> (1996) открывал новое соединение для каждого запроса. То есть если дизайн сайта содержал 100 картинок, то приходилось открывать и использовать 100 соединений для их загрузки и отображения пользователю. Такая схема, естественно, работала медленно</p>
    <p>Проблему с производительностью HTTP 1.0 нужно было решать. Для этого разработчики протокола создали новую версию — <b>HTTP 1.1</b> (1999), где запросы стали передавать последовательно через одно и тоже соединение. Это значительно улучшило ситуацию. Причем, скорость и новый функционал всех устроил настолько, что его не трогали еще полтора десятка лет.
    </p>
    <p>Требовалось увеличить скорость работы протокола. Так появился <b>HTTP 2.0</b> (2015). В нем вместо текстовых данных стали использовать бинарные, так как они обрабатываются компьютером быстрее. Но это не главное, главной особенностью стала возможность передавать данные пакетами, то есть за раз теперь передаётся несколько запросов и возвращается несколько ответов.</p>
    <p>Кроме HTTP в интернете работает ещё протокол <b>HTTPS</b>. Аббревиатура расшифровывается как «защищённый протокол передачи гипертекста» (или HyperText Transfer Protocol Secure). Он нужен для безопасной передачи данных по Сети. Всё происходит по тем же принципам, как и у HTTP, правда, перед отправкой данные дополнительно шифруются, а затем расшифровываются на сервере. Например, HTTPS используют во время ввода данных банковской карты или паролей на сайтах — да и в целом большинство современных сайтов используют именно его.</p>
</details>


### Какие знаете коды ответа (состояния) HTTP?
  <details>
    <summary>Ответ:</summary>
      <p>Информационные 100 - 199</p>
      <p>Успешные 200 - 299</p>
      <p>Перенаправления 300 - 399</p>
      <p>Клиентские ошибки 400 - 499</p>
      <p>Серверные ошибки 500 - 599</p>
      <h4><b>Список популярных ответов</b></h4>

| Код   | Описание               |
| ------| ---------------------- |
| 200   | OK                     |   
| 400   | Bad Request            |   
| 401   | Unauthorized           |  
| 403   | Forbidden              |  
| 404   | Not Found              |
| 408   | Request Timeout        |
| 500   | Internal Server Error  |
| 502   | Bad Gateway            |
| 503   | Service Unavailable    |
  </details>

### Что такое Cross-Origin Resource Sharing? Как устранить проблемы с CORS?
  <details>
    <summary>Ответ:</summary>
     <p><b>Cross-origin resource sharing</b> (CORS; с англ. — «совместное использование ресурсов между разными источниками») — технология современных браузеров, которая позволяет предоставить веб-страницам доступ к ресурсам другого домена.</p>
     <p>Есть три домена, позволяющие загрузить ресурсы с сервера U. Для того, чтобы это стало возможным, веб-серверу U, который отдает контент, достаточно указать в заголовке ответа Access-Control-Allow-Origin список доверенных доменов: A, B, C. Тогда для страниц этих доменов не будут действовать ограничения принципа одинакового источника на запрашиваемые страницы:
     </p>
     <p>Access-Control-Allow-Origin: A, B, C</p>
     <p>После этого, страницы доменов A, B, C смогут загружать контент с сервера U.</p>
     <h4>Cпособы устранения проблем с CORS</h4>

  - можно запустить локальный proxy сервер, который будет пересылать данные между нашим приложением и сервером, добавляя необходимые заголовки
  - помимо прокси сервера, для разработки можно запустить специальный инстанс браузера, в котором отключены CORS
  - также можно использовать специальные расширения браузера, которые отключают CORS
  - для тестирования можно запустить хром с --disable-web-security

  Хорошая статья на тему CORS [ здесь ](https://medium.com/nuances-of-programming/%D0%BA%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D0%BD%D0%B0%D1%8F-%D0%BD%D0%B0%D1%83%D0%BA%D0%B0-%D0%BD%D0%B0%D0%B3%D0%BB%D1%8F%D0%B4%D0%BD%D0%BE-cors-20a97786c18c)
  </details>

### Что такое cookie?
  <details>
    <summary>Ответ:</summary>
    <p><b>Ку́ки</b> (англ. cookie, букв. — «печенье») — небольшой фрагмент данных, отправленный веб-сервером и хранимый на компьютере пользователя. Веб-клиент (обычно веб-браузер) всякий раз при попытке открыть страницу соответствующего сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса. Применяется для сохранения данных на стороне пользователя, на практике обычно используется для:</p>

  - аутентификации пользователя;
  - хранения персональных предпочтений и настроек пользователя;
  - отслеживания состояния сеанса доступа пользователя;
  - сведения статистики о пользователях.

  <p>Поддержки браузерами cookie (приём, сохранение и последующая пересылка серверу сохранённых cookie) требуют многие сайты с ограничениями доступа, большинство интернет-магазинов. Настройка оформления и поведения многих веб-сайтов по индивидуальным предпочтениям пользователя тоже основана на cookie.</p>
  </details>

### Какой максимальный размер cookie?
  <details>
    <summary>Ответ:</summary>
    <p>Спецификации указывают минимальные объёмы, которые должны предоставляться браузерами для хранения cookie. Так, браузер должен хранить по меньшей мере 300 cookie по 4096 байт каждая, и по меньшей мере 20 cookie для одного сервера или домена.
    </p>
    <h4>Популярные браузеры имеют соответствующий максимум хранящихся cookie для каждого домена:</h4>

| Бразуер                 | Количество cookie  |
| ------------------------| ------------------ |
| Internet Explorer 6/7   | 20                 |   
| Opera 9                 | 30                 |   
| Firefox 2.0             | 50                 |  
| Google Chrome 58.0      | 176                |  
| Safari 10.0             | 242                |

  <p>На практике, некоторые браузеры могут накладывать более жёсткие ограничения. К примеру, Internet Explorer предоставляет 4096 байт для всех cookie в одном домене.</p>
  </details>


### Что означает директива use strict?
  <details>
  <summary>Ответ:</summary>
  <p>Семантика строгого режима отличается от традиционного нестрогого режима, который иногда называют «грязным» (sloppy mode). В таком режиме синтаксические правила языка не так строги, а когда происходят некоторые ошибки, система никак не оповещает о них пользователя. То есть — ошибки могут быть проигнорированы, а код, в котором они допущены, сможет выполняться дальше. Это способно привести к неожиданным результатам выполнения кода.</p>

  <h4>Пример ошибок, которые отлавливает js с помощью use strict:</h4>

  - cоздание переменных без ключевого слово (var/let/const)
  - перезаписывание значений глобальных сущностей типа arguments, NaN или eval, undefined, null
  - создание у объекта свойств с одинаковыми значениями
  - создание функций с одинаковыми названиями параметров

  </details>

### Что такое статическая и динамическая типизации?
  <details>
  <summary>Ответ:</summary>
  
  <p>В <b>динамически</b> типизированном языке у одной и той же переменной могут быть разные типы в разных частях программы, а в <b>статически</b> типизированном, если вы задали переменной тип string, у неё будет только тип string.</p>

  <p>В языках с динамической типизацией типы определяются во время выполнения программы. Статическая типизация значит, что типы определяются на этапе компиляции. То есть ошибки в типах будут видны ещё до того, как программа запустится. </p>
  </details>

### Как клиент взаимодействует с сервером?
  <details>
  <summary>Ответ:</summary>
  
  <p>Клиент и сервер взаимодействую друг с другом в сети Интернет или в любой другой компьютерной сети при помощи различных сетевых протоколов, например, IP протокол, HTTP протокол, FTP и другие. Протоколов на самом деле очень много и каждый протокол позволяет оказывать ту или иную услугу. Например, при помощи HTTP протокола браузер отправляет специальное HTTP сообщение, в котором указано какую информацию и в каком виде он хочет получить от сервера, сервер, получив такое сообщение, отсылает браузеру в ответ похожее по структуре сообщение (или несколько сообщений), в котором содержится нужная информация, обычно это HTML документ.</p>

  <p>Сообщения, которые посылают клиенты получили названия HTTP запросы. Запросы имеют специальные методы, которые говорят серверу о том, как обрабатывать сообщение. А сообщения, которые посылает сервер получили название HTTP ответы, они содержат помимо полезной информации еще и специальные коды состояния, которые позволяют браузеру узнать то, как сервер понял его запрос.</p>
  </details>

### Что такое REST?
  <details>
  <summary>Ответ:</summary>

  <p><b>REST</b> (REpresentational State Transfer) — это архитектура, т.е. принципы построения распределенных гипермедиа систем, того что другими словами называется World Wide Web, включая универсальные способы обработки и передачи состояний ресурсов по HTTP
  </p>
  <h4>Требования к архитектуре REST</h4>

1. <b>Приведение архитектуры к модели клиент-сервер</b>

В основе данного ограничения лежит разграничение потребностей. Необходимо отделять потребности клиентского интерфейса от потребностей сервера, хранящего данные. Данное ограничение повышает переносимость клиентского кода на другие платформы, а упрощение серверной части улучшает масштабируемость системы. Само разграничение на “клиент” и “сервер” позволяет им развиваться независимо друг от друга.

2. <b>Отсутствие состояния</b>

Архитектура REST требует соблюдения следующего условия. В период между запросами серверу не нужно хранить информацию о состоянии клиента и наоборот. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Таким образом и сервер, и клиент могут «понимать» любое принятое сообщение, не опираясь при этом на предыдущие сообщения.

3. <b> Кэширование </b>

Клиенты могут выполнять кэширование ответов сервера. У тех, в свою очередь, должно быть явное или неявное обозначение как кэшируемых или некэшируемых, чтобы клиенты в ответ на последующие запросы не получали устаревшие или неверные данные. Правильное использование кэширования помогает полностью или частично устранить некоторые клиент-серверные взаимодействия, ещё больше повышая производительность и расширяемость системы.

4. <b> Единообразие интерфейса </b>

К фундаментальным требованиям REST архитектуры относится и унифицированный, единообразный интерфейс. Клиент должен всегда понимать, в каком формате и на какие адреса ему нужно слать запрос, а сервер, в свою очередь, также должен понимать, в каком формате ему следует отвечать на запросы клиента. Этот единый формат клиент-серверного взаимодействия, который описывает, что, куда, в каком виде и как отсылать и является унифицированным интерфейсом

5. <b> Слои </b>

Под слоями подразумевается иерархическая структура сетей. Иногда клиент может общаться напрямую с сервером, а иногда — просто с промежуточным узлом. Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования. Приведем пример. Представим себе некоторое мобильное приложение, которое пользуется популярностью во всем мире. Его неотъемлемая часть — загрузка картинок. Так как пользователей — миллионы человек, один сервер не смог бы выдержать такой большой нагрузки. Разграничение системы на слои решит эту проблему. Клиент запросит картинку у промежуточного узла, промежуточный узел запросит картинку у сервера, который наименее загружен в данный момент, и вернет картинку клиенту. Если здесь на каждом уровне иерархии правильно применить кэширование, то можно добиться хорошей масштабируемости системы.

6. <b> Код по требованию (необязательное ограничение) </b>

Данное ограничение подразумевает, что клиент может расширять свою функциональность, за счет загрузки кода с сервера в виде апплетов или сценариев.

<h4>Преимущества, которые дает REST</h4>

  - производительность (за счёт использования кэша)
  - масштабируемость
  - прозрачность системы взаимодействия
  - простота интерфейсов
  - портативность компонентов
  - лёгкость внесения изменений
  - способность эволюционировать, приспосабливаясь к новым требованиям

  </details>

### Какие в JS есть типы данных?
<details>
  <summary>Ответ:</summary>
    <p>В JS существует 8 типов данных: Undefined, Boolean, Number, String, BigInt, Symbol, Null, Object</p>
</details>

### Как проверить, является ли объект массивом?
<details>
  <summary>Ответ:</summary>
    <p>Существует метод Array.isArray() возвращает true, если объект является массивом и false, если он массивом не является.</p>
</details>

### Как проверить, является ли число конечным?
<details>
  <summary>Ответ:</summary>
    <p>Метод Number.isFinite() определяет, является ли значение конечным числом.</p>

```js
Number.isFinite(25) //true 
Number.isFinite(-1.22) //true 
Number.isFinite(15-2) //true
Number.isFinite(0) //true
Number.isFinite('25') //false
Number.isFinite('Hi') //false
Number.isFinite('2019/01/01') //false
Number.isFinite(Infinity) //false
Number.isFinite(-Infinity) //false
Number.isFinite(25 / 0) //false
```
</details>

### Как проверить, что переменная равна NaN?
<details>
  <summary>Ответ:</summary>
    <p>
        Метод Number.isNaN() определяет, является ли значение NaN (Not-A-Number).
        Этот метод возвращает true, если значение имеет тип Number и является NaN. В противном случае метод возвращает false.
    </p>
    <p>Number.isNaN () отличается от глобальной функции isNaN(). Глобальная функция isNaN() преобразует тестируемое значение в число, а затем проверяет его.</p>
    <p>Number.isNaN() не преобразует значения в число и не возвращает true для любого значения, которое не относится к типу Number</p>
    <p><b>Совет.</b> В JavaScript значение NaN относится к типу данных — число.</p>

```js
Number.isNaN('') //false
Number.isNaN(true) //false
Number.isNaN(undefined) //false
Number.isNaN('NaN') //false
Number.isNaN(NaN) //true
Number.isNaN(25/ 0) //true
```
</details>

### Сравните ключевые слова var, let, const.
<details>
  <summary>Ответ:</summary>

| Var                                                                                                | Let | Const |
|----------------------------------------------------------------------------------------------------|-----|---------|
| Область видимости переменной var — это глобальная область.                                         | Область видимости переменной let является областью действия блока. | Область видимости переменной let является областью действия блока. 
| Его можно обновить и повторно объявить в области видимости.                                        | Его можно обновить, но нельзя повторно объявить в области видимости. | Его нельзя обновить или повторно объявить в области видимости. 
| Его можно объявить без инициализации.                                                              | Его можно объявить без инициализации. | Его нельзя объявить без инициализации. 
| Доступ к нему можно получить без инициализации, так как его значение по умолчанию «не определено». | К нему нельзя получить доступ без инициализации, иначе он выдаст «referenceError». | К нему нельзя получить доступ без инициализации, так как его нельзя объявить без инициализации.
| При объявление переменной она всплывает в глобальную область видимости.                            | При объявление переменной она не всплывает в глобальную область видимости, а имеент блочную область видимости | При объявление переменной она не всплывает в глобальную область видимости, а имеент блочную область видимости 
</details>

### Что такое область видимости?
<details>
  <summary>Ответ:</summary>
    <p><b>Область видимости</b> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту.
Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.
Мы всегда можем получить доступ к глобальной области видимости, но не можем получить доступ из вне, например к переменным
функции.</p>
</details>

### Что такое деструктуризация?
<details>
  <summary>Ответ:</summary>
    <p>Деструктуризация (destructuring) – синтаксическая возможность "раскладывать" элементы массива (и не только) в отдельные константы или переменные. Деструктуризация относится к необязательным, но очень приятным возможностям языка.</p>

```js
// Деструктуризация массива
const profile = ["Oluwatobi", "Sofela", "codesweetly.com"];
const [firstName, lastName, website] = profile;
console.log(firstName); // "Oluwatobi"
console.log(lastName); // "Sofela"
console.log(website); // "codesweetly.com"

// Деструктуризация объекта
const profile = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};
const { firstName: forename, lastName: surname, website: onlineSite } = profile;
console.log(forename); // "Oluwatobi"
console.log(surname); // "Sofela"
console.log(onlineSite); // "codesweetly.com"
console.log(website); // "ReferenceError: website is not defined"

// Еще пример Деструктуризации объекта
const { firstName, lastName, website } = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};
console.log(firstName); // "Oluwatobi"
console.log(lastName); // "Sofela"
console.log(website); // "codesweetly.com"

// И Еще пример Деструктуризации объекта
const { firstName, ...otherInfo } = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};

console.log(firstName); // "Oluwatobi"
console.log(otherInfo); // {lastName: "Sofela", website: "codesweetly.com"}
```
</details>

### Для чего предназначены методы setTimeout и setInterval?
<details>
  <summary>Ответ:</summary>
    <p>В JavaScript имеются методы, которые позволяют вызвать функцию не сразу, а через некоторый промежуток времени 
(в асинхронном режиме). Называются они setTimeout и setInterval. Отличаются они друг от друга лишь тем, что setTimeout 
выполняет вызов функции всего один раз, а setInterval – постоянно через указанный интервал времени.</p>
</details>

### Опишите назначение и принципы работы с коллекциями Map и Set.
<details>
  <summary>Ответ:</summary>
    <p>Map - это коллекция пар ключ/значение, как и Object. Но основное отличие, что Map позволяет использовать ключи
любого типа, также у него есть собственные метода, например: Map.size()</p>
    <p>Set - это особый вид коллекции, где каждое значение является уникальным.</p>
</details>

### Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?
<details>
  <summary>Ответ:</summary>
    <p>При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).</p>
    <p>Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.</p>

<b>Поверхностная копия объекта</b>
```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }
```

<b>Поверхностная копия массива</b>
```js
const itemsInCart = [
  { product: 'Носки', quantity: 3 },
  { product: 'Штаны', quantity: 1 },
  { product: 'Кепка', quantity: 1 },
]
const clonedCart = [...itemsInCart]
```

<p>Для глубокого копирования недостаточно просто скопировать let clone = Object.assign({}, user); потому что clone.sizes = user.sizes, user.sizes – это объект, он будет скопирован по ссылке. Таким образом, clone и user будут иметь общий объект sizes:</p>

```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};
let clone = Object.assign({}, user);
alert( user.sizes === clone.sizes ); // true, тот же объект
// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом
```

<p>Самый быстрый способ глубокого копирования звучит глупо — нужно сериализовать копируемый объект в JSON и тут же распарсить его. В результате появится полная копия объекта:</p>

```js
const itemsInCart = [
  { product: 'Носки', quantity: 3 },
  { product: 'Штаны', quantity: 1 },
  { product: 'Кепка', quantity: 1 },
]
const deep = JSON.parse(JSON.stringify(itemsInCart))
console.log(itemsInCart[1] === deep[1]) // false
```
</details>

### В чем разница между оператором in и методом hasOwnProperty?
<details>
  <summary>Ответ:</summary>
    <p>Оператор in возвращает значение true, если к свойству можно получить доступ через объект или через прототип-объекта.</p>
    <p>hasOwnProperty () возвращает значение true, только если свойство существует в экземпляре.</p>

```js
function Person(){
}
Person.prototype.name = "Nicholas";
var person1 = new Person();
alert(person1.hasOwnProperty("name"));//false
alert("name" in person1);//true

person1.name = "Greg";
alert(person1.name);//"Greg"
alert(person1.hasOwnProperty("name"));//true
alert("name" in person1);//true
```
</details>

### Что такое прототип? Как работает прототипное наследование в JS?
<details>
  <summary>Ответ:</summary>
    <p>Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. Каждый объект в JavaScript имеет внутреннее свойство, называемое [[Prototype]]</p>
    <p><b>Примечание:</b> Двойные квадратные скобки в [[Prototype]] означают, что свойство является внутренним и не может быть доступно непосредственно в коде.</p>
    <p>Чтобы найти свойство [[Prototype]] объекта, нужно использовать метод getPrototypeOf ().</p>
    <p>Еще один способ найти [[Prototype]] – это свойство __proto__, которое предоставляет внутренний [[Prototype]] объекта.</p>
    <p> Значение свойства prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

Таким образом Object.prototype.watch(), Object.prototype.valueOf() и т. д. доступны для любых типов объектов, которые наследуются от Object.prototype, включая новые экземпляры объектов.</p>
    <p>Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.</p>
    <p>Встроенные в JavaScript объекты можно расширять и изменять. Что интересно, изменение некоторых из них
повлияет и на примитивы. Можно добавить методы стандартным числам, строкам, и не только.</p>
</details>


### Расскажите о базовом устройстве и механизме работы Event loop.
<details>
  <summary>Ответ:</summary>
    <p>Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на другое событие, а после — возобновить выполнение первого. Все события обрабатываются последовательно и каждое — до победного конца.</p>
    <p>Для вышеописанного потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.</p>
    <p>Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.</p>
    
![Event Loop](https://miro.medium.com/max/1100/1*quyTIOs2hioCx1jRQ7-ojw.png)
</details>

### Что такое Promise? Назовите порядок выполнения then и catch в цепочке.
<details>
  <summary>Ответ:</summary>
<p>Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.</p>
<p>Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса работает асинхронная операция, которая управляет его состоянием.</p>
<p>Промис может находиться в одном из трёх состояний:</p>

1. pending — стартовое состояние, операция стартовала;
2. fulfilled — получен результат;
3. rejected — ошибка.

<p>Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected:</p>
<p>У промиса есть методы then() и catch(), которые позволяют выполнять код при изменении его состояния.</p>

```js
Promise.resolve(10)
  .then(e => console.log(e)) // 10
  .then(e => Promise.resolve(e))
  .then(console.log) // undefined
  .then(e => {
    if (!e) {
      throw 'Error caught';
    }
  })
  .catch(e => {
    console.log(e); // 'Error caught'
    return new Error('New error');
  })
  .then(e => {
    console.log(e.message); // New error
  })
  .catch(e => {
    console.log(e.message); // Promise{<fulfilled>: undefined}
  });
```
</details>

### Что такое Promise.all()?
<details>
  <summary>Ответ:</summary>
<p>Метод Promise.all(iterable) возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента, или отклонено любое из переданных промисов.</p>

```js
var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, "foo");
});
Promise.all([p1, p2, p3]).then(values => {
  console.log(values);
});
//Выведет:
// [3, 1337, "foo"] 
```
</details>

### Расскажите о типе данных Symbol и его практическом применении.
<details>
  <summary>Ответ:</summary>
<p>Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.
Даже если символы имеют одно и то же имя, это – разные символы.</p>
</details>

### В чем разница между декларацией функции (function declaration) и функциональным выражением (function expression)?
<details>
  <summary>Ответ:</summary>

+ Function Declaration - функция, объявленная в основном потоке кода.
+ Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.
<p>Несмотря на немного разный вид, по сути две эти записи делают одно и то же:</p>

```js
// Function Declaration
function sum(a, b) {
  return a + b;
}
// Function Expression
var sum = function(a, b) {
  return a + b;
}
```
<p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Поэтому их можно вызвать до объявления, а если бы это было объявление Function Expression, то такой вызов бы не сработал:</p>

```js
sayHi("Вася"); // Привет, Вася
function sayHi(name) {
  console.log( "Привет, " + name );
}

//-------------------------
sayHi("Вася"); // ошибка!
var sayHi = function(name) {
  console.log( "Привет, " + name );
}
```

</details>

### Что такое анонимная функция?
<details>
  <summary>Ответ:</summary>
<p>Анонимная функция (еще можно встретить такое название как лямбды) - особый вид функций, которые объявляются в месте использования и не получают уникального идентификатора для доступа к ним. Может быть использована в момент объявления, можно присвоить переменной и т.п.</p>
<p>Например:</p>

```js
button.addEventListener('click', function (event) {
    // эта анонимная функция будет вызвана при клике
}, false);
```
</details>


### Что такое функция высшего порядка? 
<details>
  <summary>Ответ:</summary>
<p>Функции высшего порядка - это функции, принимающие другую функцию как аргумент или возвращающие функцию (например, map, filter).</p>
</details>

### Что такое чистая функция? 
<details>
  <summary>Ответ:</summary>
<p>Чистая функция - это функция, которая:</p>

+ при одинаковых аргументах всегда возвращает одни и те же значения
+ не имеет видимых побочных эффектов, т.е. не изменяет какое либо состояние за пределами ее области видимости и не оказывает видимого воздействия на внешний мир, кроме возвращения значения
</details>

### Что такое побочный эффект у функций?
<details>
  <summary>Ответ:</summary>
<p>Побочный эффект - это изменение состояния системы или заметное взаимодействие с окружающим "миром", которое происходит во время вычисления результата.
Например:</p>

+ изменение в файловой ситсеме 
+ вставка в БД 
+ выполнение http запроса 
+ мутации 
+ вывод на экран / запись в лог 
+ получение данных от пользователя 
+ выполение запроса к DOM 
+ получение доступа к состоянию системы
</details>

### Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?
<details>
<summary>Ответ:</summary>
<p>Immediately (немедленно) Invoked (вызываемое) Function (функциональное) Expression (выражение) или "вызов функциональных выражений по месту"</p>
<p>Вариация IIFE, которая широко распространена, это использование того факта, что они, на самом деле, просто вызовы функций, и передача им аргумента(ов).</p>

```js
var a = 2;
(function IIFE( global ){
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );
console.log( a ); // 2
```
</details>

### Что такое hoisting, как он работает для переменных и функций?
<details>
<summary>Ответ:</summary>
<p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх 
своей области видимости перед тем, как код будет выполнен.  Компиляция кода происходит в два прохода. При первом проходе
компилятор получает все объявления переменных, все идентификаторы. При этом никакой код не выполняется, методы не 
вызываются. При втором проходе собственно происходит выполнение. И даже если переменная определена после 
непосредственного использования, ошибки не возникнет, так как при первом проходе компилятору уже известны все переменные.
Стоит отметить что, переменные, объявленные при помощи let и const, поднимаются, но не инициализируются с дефолтным значением. 
Попытка доступа к let или const-переменной до ее объявления приведет к ReferenceError:</p>

```js
console.log(foo); // Uncaught ReferenceError: Cannot access 'foo' before initialization
let foo = 'bar';  // Переменные, объявленные с помощью const, ведут себя так же
```
</details>

### Что такое замыкание (closure) и каковы сценарии его использования?
<details>
  <summary>Ответ:</summary>
<p>Замыкание - это функция, содержащая в себе ссылки на переменные из внешней области видимости. Т.е. она "замыкает" 
внешние переменные в себе.</p>

```js
var counter = (function () {
  var current = 0;
  return function () {
    current++;
    return current;
  }
})();
console.log(counter()); // 1
console.log(counter()); // 2
```
</details>

### Как вы понимаете замыкания? Что будет выведено в консоли в этом случае?

```js
var f = function() {
  console.log(1);
}
var execute = function(f) {
  setTimeout(f, 1000);
}
execute(f); // что выведет в консоль и почему
f = function() {
  console.log(2);
}
```
<details>
<summary>Ответ:</summary>
<b>1</b>
</details>

### Что такое рекурсия?
<details>
  <summary>Ответ:</summary>
<p>Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть 
использованы для элегантного решения определённых задач</p>

```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
pow(2, 2) // 4
pow(2, 3) // 8
pow(2, 4) // 16
```
</details>