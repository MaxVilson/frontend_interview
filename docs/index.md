### Какие в JS есть типы данных?
<details>
  <summary>Ответ:</summary>
    <p>В JS существует 8 типов данных: Undefined, Boolean, Number, String, BigInt, Symbol, Null, Object</p>
</details>

### Как проверить, является ли объект массивом?
<details>
  <summary>Ответ:</summary>
    <p>Существует метод Array.isArray() возвращает true, если объект является массивом и false, если он массивом не является.</p>
</details>

### Как проверить, является ли число конечным?
<details>
  <summary>Ответ:</summary>
    <p>Метод Number.isFinite() определяет, является ли значение конечным числом.</p>

```js
Number.isFinite(25) //true 
Number.isFinite(-1.22) //true 
Number.isFinite(15-2) //true
Number.isFinite(0) //true
Number.isFinite('25') //false
Number.isFinite('Hi') //false
Number.isFinite('2019/01/01') //false
Number.isFinite(Infinity) //false
Number.isFinite(-Infinity) //false
Number.isFinite(25 / 0) //false
```
</details>

### Как проверить, что переменная равна NaN?
<details>
  <summary>Ответ:</summary>
    <p>
        Метод Number.isNaN() определяет, является ли значение NaN (Not-A-Number).
        Этот метод возвращает true, если значение имеет тип Number и является NaN. В противном случае метод возвращает false.
    </p>
    <p>Number.isNaN () отличается от глобальной функции isNaN(). Глобальная функция isNaN() преобразует тестируемое значение в число, а затем проверяет его.</p>
    <p>Number.isNaN() не преобразует значения в число и не возвращает true для любого значения, которое не относится к типу Number</p>
    <p><b>Совет.</b> В JavaScript значение NaN относится к типу данных — число.</p>

```js
Number.isNaN('') //false
Number.isNaN(true) //false
Number.isNaN(undefined) //false
Number.isNaN('NaN') //false
Number.isNaN(NaN) //true
Number.isNaN(25/ 0) //true
```
</details>

### Сравните ключевые слова var, let, const.
<details>
  <summary>Ответ:</summary>

| Var                                                                                                | Let | Const |
|----------------------------------------------------------------------------------------------------|-----|---------|
| Область видимости переменной var — это глобальная область.                                         | Область видимости переменной let является областью действия блока. | Область видимости переменной let является областью действия блока. 
| Его можно обновить и повторно объявить в области видимости.                                        | Его можно обновить, но нельзя повторно объявить в области видимости. | Его нельзя обновить или повторно объявить в области видимости. 
| Его можно объявить без инициализации.                                                              | Его можно объявить без инициализации. | Его нельзя объявить без инициализации. 
| Доступ к нему можно получить без инициализации, так как его значение по умолчанию «не определено». | К нему нельзя получить доступ без инициализации, иначе он выдаст «referenceError». | К нему нельзя получить доступ без инициализации, так как его нельзя объявить без инициализации.
| При объявление переменной она всплывает в глобальную область видимости.                            | При объявление переменной она не всплывает в глобальную область видимости, а имеент блочную область видимости | При объявление переменной она не всплывает в глобальную область видимости, а имеент блочную область видимости 
</details>

### Что такое область видимости?
<details>
  <summary>Ответ:</summary>
    <p><b>Область видимости</b> — это часть программы, в которой мы можем обратиться к переменной, функции или объекту.
Этой частью может быть функция, блок или вся программа в целом — то есть мы всегда находимся как минимум в одной области видимости.
Мы всегда можем получить доступ к глобальной области видимости, но не можем получить доступ из вне, например к переменным
функции.</p>
</details>

### Что такое деструктуризация?
<details>
  <summary>Ответ:</summary>
    <p>Деструктуризация (destructuring) – синтаксическая возможность "раскладывать" элементы массива (и не только) в отдельные константы или переменные. Деструктуризация относится к необязательным, но очень приятным возможностям языка.</p>

```js
// Деструктуризация массива
const profile = ["Oluwatobi", "Sofela", "codesweetly.com"];
const [firstName, lastName, website] = profile;
console.log(firstName); // "Oluwatobi"
console.log(lastName); // "Sofela"
console.log(website); // "codesweetly.com"

// Деструктуризация объекта
const profile = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};
const { firstName: forename, lastName: surname, website: onlineSite } = profile;
console.log(forename); // "Oluwatobi"
console.log(surname); // "Sofela"
console.log(onlineSite); // "codesweetly.com"
console.log(website); // "ReferenceError: website is not defined"

// Еще пример Деструктуризации объекта
const { firstName, lastName, website } = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};
console.log(firstName); // "Oluwatobi"
console.log(lastName); // "Sofela"
console.log(website); // "codesweetly.com"

// И Еще пример Деструктуризации объекта
const { firstName, ...otherInfo } = {
  firstName: "Oluwatobi",
  lastName: "Sofela",
  website: "codesweetly.com"
};

console.log(firstName); // "Oluwatobi"
console.log(otherInfo); // {lastName: "Sofela", website: "codesweetly.com"}
```
</details>

### Для чего предназначены методы setTimeout и setInterval?
<details>
  <summary>Ответ:</summary>
    <p>В JavaScript имеются методы, которые позволяют вызвать функцию не сразу, а через некоторый промежуток времени 
(в асинхронном режиме). Называются они setTimeout и setInterval. Отличаются они друг от друга лишь тем, что setTimeout 
выполняет вызов функции всего один раз, а setInterval – постоянно через указанный интервал времени.</p>
</details>

### Опишите назначение и принципы работы с коллекциями Map и Set.
<details>
  <summary>Ответ:</summary>
    <p>Map - это коллекция пар ключ/значение, как и Object. Но основное отличие, что Map позволяет использовать ключи
любого типа, также у него есть собственные метода, например: Map.size()</p>
    <p>Set - это особый вид коллекции, где каждое значение является уникальным.</p>
</details>

### Что означает глубокая (deep) и поверхностная (shallow) копия объекта? Как сделать каждую из них?
<details>
  <summary>Ответ:</summary>
    <p>При копировании объектов или массивов JavaScript копирует данные только на один уровень вглубь. Этот тип копирования называется поверхностным (shallow).</p>
    <p>Если необходимо полностью скопировать сложную структуру данных, например, массив с объектами, то нужно делать глубокое (deep) или полное копирование данных. JavaScript не содержит функций для глубокого копирования, лучший вариант сделать глубокую копию — сериализовать структуру в JSON и тут же распарсить.</p>

<b>Поверхностная копия объекта</b>
```js
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }
```

<b>Поверхностная копия массива</b>
```js
const itemsInCart = [
  { product: 'Носки', quantity: 3 },
  { product: 'Штаны', quantity: 1 },
  { product: 'Кепка', quantity: 1 },
]
const clonedCart = [...itemsInCart]
```

<p>Для глубокого копирования недостаточно просто скопировать let clone = Object.assign({}, user); потому что clone.sizes = user.sizes, user.sizes – это объект, он будет скопирован по ссылке. Таким образом, clone и user будут иметь общий объект sizes:</p>

```js
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};
let clone = Object.assign({}, user);
alert( user.sizes === clone.sizes ); // true, тот же объект
// user и clone обладают общим свойством sizes
user.sizes.width++;       // изменяем свойства в первом объекте
alert(clone.sizes.width); // 51, видим результат в другом
```

<p>Самый быстрый способ глубокого копирования звучит глупо — нужно сериализовать копируемый объект в JSON и тут же распарсить его. В результате появится полная копия объекта:</p>

```js
const itemsInCart = [
  { product: 'Носки', quantity: 3 },
  { product: 'Штаны', quantity: 1 },
  { product: 'Кепка', quantity: 1 },
]
const deep = JSON.parse(JSON.stringify(itemsInCart))
console.log(itemsInCart[1] === deep[1]) // false
```
</details>

### В чем разница между оператором in и методом hasOwnProperty?
<details>
  <summary>Ответ:</summary>
    <p>Оператор in возвращает значение true, если к свойству можно получить доступ через объект или через прототип-объекта.</p>
    <p>hasOwnProperty () возвращает значение true, только если свойство существует в экземпляре.</p>

```js
function Person(){
}
Person.prototype.name = "Nicholas";
var person1 = new Person();
alert(person1.hasOwnProperty("name"));//false
alert("name" in person1);//true

person1.name = "Greg";
alert(person1.name);//"Greg"
alert(person1.hasOwnProperty("name"));//true
alert("name" in person1);//true
```
</details>

### Что такое прототип? Как работает прототипное наследование в JS?
<details>
  <summary>Ответ:</summary>
    <p>Прототипы - это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга. Каждый объект в JavaScript имеет внутреннее свойство, называемое [[Prototype]]</p>
    <p><b>Примечание:</b> Двойные квадратные скобки в [[Prototype]] означают, что свойство является внутренним и не может быть доступно непосредственно в коде.</p>
    <p>Чтобы найти свойство [[Prototype]] объекта, нужно использовать метод getPrototypeOf ().</p>
    <p>Еще один способ найти [[Prototype]] – это свойство __proto__, которое предоставляет внутренний [[Prototype]] объекта.</p>
    <p> Значение свойства prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов.

Таким образом Object.prototype.watch(), Object.prototype.valueOf() и т. д. доступны для любых типов объектов, которые наследуются от Object.prototype, включая новые экземпляры объектов.</p>
    <p>Объект-прототип так же может иметь свой прототип и наследовать его свойства и методы и так далее. Это часто называется цепочкой прототипов и объясняет почему одним объектам доступны свойства и методы которые определены в других объектах.</p>
    <p>Встроенные в JavaScript объекты можно расширять и изменять. Что интересно, изменение некоторых из них
повлияет и на примитивы. Можно добавить методы стандартным числам, строкам, и не только.</p>
</details>


### Расскажите о базовом устройстве и механизме работы Event loop.
<details>
  <summary>Ответ:</summary>
    <p>Движок браузера выполняет JavaScript в одном потоке. Он не может поставить обработку события на паузу, переключиться на другое событие, а после — возобновить выполнение первого. Все события обрабатываются последовательно и каждое — до победного конца.</p>
    <p>Для вышеописанного потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.</p>
    <p>Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.</p>
    
![Event Loop](https://miro.medium.com/max/1100/1*quyTIOs2hioCx1jRQ7-ojw.png)
</details>

### Что такое Promise? Назовите порядок выполнения then и catch в цепочке.
<details>
  <summary>Ответ:</summary>
<p>Промис (Promise) — специальный объект JavaScript, который используется для написания и обработки асинхронного кода.</p>
<p>Асинхронные функции возвращают объект Promise в качестве значения. Внутри промиса работает асинхронная операция, которая управляет его состоянием.</p>
<p>Промис может находиться в одном из трёх состояний:</p>

1. pending — стартовое состояние, операция стартовала;
2. fulfilled — получен результат;
3. rejected — ошибка.

<p>Поменять состояние можно только один раз: перейти из pending либо в fulfilled, либо в rejected:</p>
<p>У промиса есть методы then() и catch(), которые позволяют выполнять код при изменении его состояния.</p>

```js
Promise.resolve(10)
  .then(e => console.log(e)) // 10
  .then(e => Promise.resolve(e))
  .then(console.log) // undefined
  .then(e => {
    if (!e) {
      throw 'Error caught';
    }
  })
  .catch(e => {
    console.log(e); // 'Error caught'
    return new Error('New error');
  })
  .then(e => {
    console.log(e.message); // New error
  })
  .catch(e => {
    console.log(e.message); // Promise{<fulfilled>: undefined}
  });
```
</details>

### Что такое Promise.all()?
<details>
  <summary>Ответ:</summary>
<p>Метод Promise.all(iterable) возвращает промис, который выполнится тогда, когда будут выполнены все промисы, переданные в виде перечисляемого аргумента, или отклонено любое из переданных промисов.</p>

```js
var p1 = Promise.resolve(3);
var p2 = 1337;
var p3 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, "foo");
});
Promise.all([p1, p2, p3]).then(values => {
  console.log(values);
});
//Выведет:
// [3, 1337, "foo"] 
```
</details>

### Расскажите о типе данных Symbol и его практическом применении.
<details>
  <summary>Ответ:</summary>
<p>Символ (symbol) – примитивный тип данных, использующийся для создания уникальных идентификаторов.
Символы создаются вызовом функции Symbol(), в которую можно передать описание (имя) символа.
Даже если символы имеют одно и то же имя, это – разные символы.</p>
</details>

### В чем разница между декларацией функции (function declaration) и функциональным выражением (function expression)?
<details>
  <summary>Ответ:</summary>

+ Function Declaration - функция, объявленная в основном потоке кода.
+ Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.
<p>Несмотря на немного разный вид, по сути две эти записи делают одно и то же:</p>

```js
// Function Declaration
function sum(a, b) {
  return a + b;
}
// Function Expression
var sum = function(a, b) {
  return a + b;
}
```
<p>Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Поэтому их можно вызвать до объявления, а если бы это было объявление Function Expression, то такой вызов бы не сработал:</p>

```js
sayHi("Вася"); // Привет, Вася
function sayHi(name) {
  console.log( "Привет, " + name );
}

//-------------------------
sayHi("Вася"); // ошибка!
var sayHi = function(name) {
  console.log( "Привет, " + name );
}
```

</details>

### Что такое анонимная функция?
<details>
  <summary>Ответ:</summary>
<p>Анонимная функция (еще можно встретить такое название как лямбды) - особый вид функций, которые объявляются в месте использования и не получают уникального идентификатора для доступа к ним. Может быть использована в момент объявления, можно присвоить переменной и т.п.</p>
<p>Например:</p>

```js
button.addEventListener('click', function (event) {
    // эта анонимная функция будет вызвана при клике
}, false);
```
</details>


### Что такое функция высшего порядка? 
<details>
  <summary>Ответ:</summary>
<p>Функции высшего порядка - это функции, принимающие другую функцию как аргумент или возвращающие функцию (например, map, filter).</p>
</details>

### Что такое чистая функция? 
<details>
  <summary>Ответ:</summary>
<p>Чистая функция - это функция, которая:</p>

+ при одинаковых аргументах всегда возвращает одни и те же значения
+ не имеет видимых побочных эффектов, т.е. не изменяет какое либо состояние за пределами ее области видимости и не оказывает видимого воздействия на внешний мир, кроме возвращения значения
</details>

### Что такое побочный эффект у функций?
<details>
  <summary>Ответ:</summary>
<p>Побочный эффект - это изменение состояния системы или заметное взаимодействие с окружающим "миром", которое происходит во время вычисления результата.
Например:</p>

+ изменение в файловой ситсеме 
+ вставка в БД 
+ выполнение http запроса 
+ мутации 
+ вывод на экран / запись в лог 
+ получение данных от пользователя 
+ выполение запроса к DOM 
+ получение доступа к состоянию системы
</details>

### Что такое и для чего используют IIFE (Immediately Invoked Function Expression)?
<details>
<summary>Ответ:</summary>
<p>Immediately (немедленно) Invoked (вызываемое) Function (функциональное) Expression (выражение) или "вызов функциональных выражений по месту"</p>
<p>Вариация IIFE, которая широко распространена, это использование того факта, что они, на самом деле, просто вызовы функций, и передача им аргумента(ов).</p>

```js
var a = 2;
(function IIFE( global ){
    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2
})( window );
console.log( a ); // 2
```
</details>

### Что такое hoisting, как он работает для переменных и функций?
<details>
<summary>Ответ:</summary>
<p>Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх 
своей области видимости перед тем, как код будет выполнен.  Компиляция кода происходит в два прохода. При первом проходе
компилятор получает все объявления переменных, все идентификаторы. При этом никакой код не выполняется, методы не 
вызываются. При втором проходе собственно происходит выполнение. И даже если переменная определена после 
непосредственного использования, ошибки не возникнет, так как при первом проходе компилятору уже известны все переменные.
Стоит отметить что, переменные, объявленные при помощи let и const, поднимаются, но не инициализируются с дефолтным значением. 
Попытка доступа к let или const-переменной до ее объявления приведет к ReferenceError:</p>

```js
console.log(foo); // Uncaught ReferenceError: Cannot access 'foo' before initialization
let foo = 'bar';  // Переменные, объявленные с помощью const, ведут себя так же
```
</details>

### Что такое замыкание (closure) и каковы сценарии его использования?
<details>
  <summary>Ответ:</summary>
<p>Замыкание - это функция, содержащая в себе ссылки на переменные из внешней области видимости. Т.е. она "замыкает" 
внешние переменные в себе.</p>

```js
var counter = (function () {
  var current = 0;
  return function () {
    current++;
    return current;
  }
})();
console.log(counter()); // 1
console.log(counter()); // 2
```
</details>

### Как вы понимаете замыкания? Что будет выведено в консоли в этом случае?

```js
var f = function() {
  console.log(1);
}
var execute = function(f) {
  setTimeout(f, 1000);
}
execute(f); // что выведет в консоль и почему
f = function() {
  console.log(2);
}
```
<details>
<summary>Ответ:</summary>
<b>1</b>
</details>

### Что такое рекурсия?
<details>
  <summary>Ответ:</summary>
<p>Рекурсия – это термин в программировании, означающий вызов функцией самой себя. Рекурсивные функции могут быть 
использованы для элегантного решения определённых задач</p>

```js
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
pow(2, 2) // 4
pow(2, 3) // 8
pow(2, 4) // 16
```
</details>